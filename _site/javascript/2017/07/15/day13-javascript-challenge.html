<!DOCTYPE html>
<html>

  <head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <!-- Favicon -->
  <link rel="icon" href="/favicon.png">
  <link rel="image_src" href="/images/personal_life.png">

  <!-- Meta information -->
  <title>Day 13: JavaScript Challenge</title>
  <meta name="description"
        content="It’s all about debounce function and the ‘scroll’ event I care about.As I understand it, debounce function will prevent event listenerto fire every time the ...">
  <link rel="canonical"
        href="https://miayam.github.io/javascript/2017/07/15/day13-javascript-challenge" />

  <!-- hack.css -->
  <link rel="stylesheet" href="https://npmcdn.com/hack/dist/hack.css" />
  
    <link rel="stylesheet" href="https://npmcdn.com/hack/dist/standard.css" />
  

  <!-- Prism.js -->
  <link rel="stylesheet" href="https://npmcdn.com/prismjs@1.5.1/themes/prism.css" />

  <!-- Custom style -->
  <link rel="stylesheet" href="/css/main.css" />

  <!-- Feed -->
  <link rel="alternate" type="application/rss+xml" title="miayam.github.io"
        href="/feed.xml" />

  <!-- 'jekyll-seo' plugin -->
  <!-- Begin Jekyll SEO tag v2.0.0 -->
<title>Day 13: JavaScript Challenge - miayam.github.io</title>
<meta property="og:title" content="Day 13: JavaScript Challenge" />
<meta name="description" content="It’s all about debounce function and the ‘scroll’ event I care about.As I understand it, debounce function will prevent event listenerto fire every time the event it listen to occurred. Scrolling and resizingare the best candidates because the function that listen to those activitiesruns almost repeatedly and will significantly impact the browser’s performance.debounce function will set the duration for event listener to delay untilcertain amount of time have elapsed since the last time debounce functionwas invoked. debounce makes use of window.setTimeout, for a good reason.Lodash andUnderscore.jshave one of this kind.Well, I cherry-pick the wording from blogs and documentations and cannot makesure its originality. I am tired by the way.Here’s the demo and a bit of explanation below…(function (window, undefined) {  // These are images we want to slide in as we scroll half way through  // them.  var images = document.getElementsByClassName(&#39;slide-in&#39;);  // It&#39;s for mapping DOM elements. The Array.prototype.forEach won&#39;t work  // with NodeList.  function forEach(callback) {    for (var i = 0; i &lt; this.length; i++) {      callback.call(this, this[i], i);    }  }  // It&#39;s copy-pasted from internet, but I can explain this  // interesting function in my own words.  // It&#39;s well-explained by John Dugan http://bit.ly/2troSTT  function debounce(func, wait = 20, immediate = true) {    // It will store unique ID (number) that `window.setTimeout` return.    // For more about &#39;window.setTimeout&#39;, visit https://mzl.la/2uuQs7Z    var timeout;    return function() {      // In this case, `this` has reference to `window` object and      // `arguments` is an array-like object that includes event      // the `window` object listen to (&#39;scroll&#39;).      var context = this, args = arguments;      // This condition make function being passed to `debounce`      // function (`func`) run without having to wait as long as      // `timeout` is cleared away. So, the first time `debounce`      // return this anonymous function and have it listen to &#39;scroll&#39;      // event, `func` will run immediately.      var callNow = immediate &amp;&amp; !timeout;      // This function will fire after we have waited for certain amount      // of time. `wait` parameter contains that duration.      function later() {        // Nullify the variable that stores unique ID (number) after the        // timeout passed.        timeout = null;        // If we set `func` not to run immediately after `debounce` being        // called, run it anyway after the timeout passed.        if (!immediate) {          func.apply(context, args);        }      };      // Cancel the previous timeout, if there&#39;s any.      clearTimeout(timeout);      // Wait for a given time and run `later` function after it expires.      // Store the unique ID (number) it returns.      timeout = setTimeout(later, wait);      if (callNow) {        func.apply(context, args);      }    };  }  function slideIn(event) {    // Window position relative to our view point. I mean, as we    // scroll, at which position the window is?    var windowPosition = window.scrollY + window.innerHeight;    forEach.call(images, function (image) {      var slideInAt = windowPosition - (image.height / 2.0);      var imageBottom = image.offsetTop + image.height;      var isHalfWayThroughTheImage = slideInAt &gt; image.offsetTop;      var isNotOffTheImageBottom = window.scrollY &lt; imageBottom;      // Slide in the image if we have passed half way through it and      // the scroll position is not off the image bottom.      if (isHalfWayThroughTheImage &amp;&amp; isNotOffTheImageBottom) {        image.classList.add(&#39;active&#39;);      } else {        image.classList.remove(&#39;active&#39;);      }    });  }  window.addEventListener(&#39;scroll&#39;, debounce(slideIn, 50));})(window);" />
<meta property="og:description" content="It’s all about debounce function and the ‘scroll’ event I care about.As I understand it, debounce function will prevent event listenerto fire every time the event it listen to occurred. Scrolling and resizingare the best candidates because the function that listen to those activitiesruns almost repeatedly and will significantly impact the browser’s performance.debounce function will set the duration for event listener to delay untilcertain amount of time have elapsed since the last time debounce functionwas invoked. debounce makes use of window.setTimeout, for a good reason.Lodash andUnderscore.jshave one of this kind.Well, I cherry-pick the wording from blogs and documentations and cannot makesure its originality. I am tired by the way.Here’s the demo and a bit of explanation below…(function (window, undefined) {  // These are images we want to slide in as we scroll half way through  // them.  var images = document.getElementsByClassName(&#39;slide-in&#39;);  // It&#39;s for mapping DOM elements. The Array.prototype.forEach won&#39;t work  // with NodeList.  function forEach(callback) {    for (var i = 0; i &lt; this.length; i++) {      callback.call(this, this[i], i);    }  }  // It&#39;s copy-pasted from internet, but I can explain this  // interesting function in my own words.  // It&#39;s well-explained by John Dugan http://bit.ly/2troSTT  function debounce(func, wait = 20, immediate = true) {    // It will store unique ID (number) that `window.setTimeout` return.    // For more about &#39;window.setTimeout&#39;, visit https://mzl.la/2uuQs7Z    var timeout;    return function() {      // In this case, `this` has reference to `window` object and      // `arguments` is an array-like object that includes event      // the `window` object listen to (&#39;scroll&#39;).      var context = this, args = arguments;      // This condition make function being passed to `debounce`      // function (`func`) run without having to wait as long as      // `timeout` is cleared away. So, the first time `debounce`      // return this anonymous function and have it listen to &#39;scroll&#39;      // event, `func` will run immediately.      var callNow = immediate &amp;&amp; !timeout;      // This function will fire after we have waited for certain amount      // of time. `wait` parameter contains that duration.      function later() {        // Nullify the variable that stores unique ID (number) after the        // timeout passed.        timeout = null;        // If we set `func` not to run immediately after `debounce` being        // called, run it anyway after the timeout passed.        if (!immediate) {          func.apply(context, args);        }      };      // Cancel the previous timeout, if there&#39;s any.      clearTimeout(timeout);      // Wait for a given time and run `later` function after it expires.      // Store the unique ID (number) it returns.      timeout = setTimeout(later, wait);      if (callNow) {        func.apply(context, args);      }    };  }  function slideIn(event) {    // Window position relative to our view point. I mean, as we    // scroll, at which position the window is?    var windowPosition = window.scrollY + window.innerHeight;    forEach.call(images, function (image) {      var slideInAt = windowPosition - (image.height / 2.0);      var imageBottom = image.offsetTop + image.height;      var isHalfWayThroughTheImage = slideInAt &gt; image.offsetTop;      var isNotOffTheImageBottom = window.scrollY &lt; imageBottom;      // Slide in the image if we have passed half way through it and      // the scroll position is not off the image bottom.      if (isHalfWayThroughTheImage &amp;&amp; isNotOffTheImageBottom) {        image.classList.add(&#39;active&#39;);      } else {        image.classList.remove(&#39;active&#39;);      }    });  }  window.addEventListener(&#39;scroll&#39;, debounce(slideIn, 50));})(window);" />
<link rel="canonical" href="https://miayam.github.io/javascript/2017/07/15/day13-javascript-challenge" />
<meta property="og:url" content="https://miayam.github.io/javascript/2017/07/15/day13-javascript-challenge" />
<meta property="og:site_name" content="miayam.github.io" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2017-07-15T00:00:00+07:00" />
<script type="application/ld+json">
  {
    "@context": "http://schema.org",
    "@type": "BlogPosting",
    "headline": "Day 13: JavaScript Challenge",
    "datePublished": "2017-07-15T00:00:00+07:00",
    "description": "It’s all about debounce function and the ‘scroll’ event I care about.As I understand it, debounce function will prevent event listenerto fire every time the event it listen to occurred. Scrolling and resizingare the best candidates because the function that listen to those activitiesruns almost repeatedly and will significantly impact the browser’s performance.debounce function will set the duration for event listener to delay untilcertain amount of time have elapsed since the last time debounce functionwas invoked. debounce makes use of window.setTimeout, for a good reason.Lodash andUnderscore.jshave one of this kind.Well, I cherry-pick the wording from blogs and documentations and cannot makesure its originality. I am tired by the way.Here’s the demo and a bit of explanation below…(function (window, undefined) {  // These are images we want to slide in as we scroll half way through  // them.  var images = document.getElementsByClassName(&#39;slide-in&#39;);  // It&#39;s for mapping DOM elements. The Array.prototype.forEach won&#39;t work  // with NodeList.  function forEach(callback) {    for (var i = 0; i &lt; this.length; i++) {      callback.call(this, this[i], i);    }  }  // It&#39;s copy-pasted from internet, but I can explain this  // interesting function in my own words.  // It&#39;s well-explained by John Dugan http://bit.ly/2troSTT  function debounce(func, wait = 20, immediate = true) {    // It will store unique ID (number) that `window.setTimeout` return.    // For more about &#39;window.setTimeout&#39;, visit https://mzl.la/2uuQs7Z    var timeout;    return function() {      // In this case, `this` has reference to `window` object and      // `arguments` is an array-like object that includes event      // the `window` object listen to (&#39;scroll&#39;).      var context = this, args = arguments;      // This condition make function being passed to `debounce`      // function (`func`) run without having to wait as long as      // `timeout` is cleared away. So, the first time `debounce`      // return this anonymous function and have it listen to &#39;scroll&#39;      // event, `func` will run immediately.      var callNow = immediate &amp;&amp; !timeout;      // This function will fire after we have waited for certain amount      // of time. `wait` parameter contains that duration.      function later() {        // Nullify the variable that stores unique ID (number) after the        // timeout passed.        timeout = null;        // If we set `func` not to run immediately after `debounce` being        // called, run it anyway after the timeout passed.        if (!immediate) {          func.apply(context, args);        }      };      // Cancel the previous timeout, if there&#39;s any.      clearTimeout(timeout);      // Wait for a given time and run `later` function after it expires.      // Store the unique ID (number) it returns.      timeout = setTimeout(later, wait);      if (callNow) {        func.apply(context, args);      }    };  }  function slideIn(event) {    // Window position relative to our view point. I mean, as we    // scroll, at which position the window is?    var windowPosition = window.scrollY + window.innerHeight;    forEach.call(images, function (image) {      var slideInAt = windowPosition - (image.height / 2.0);      var imageBottom = image.offsetTop + image.height;      var isHalfWayThroughTheImage = slideInAt &gt; image.offsetTop;      var isNotOffTheImageBottom = window.scrollY &lt; imageBottom;      // Slide in the image if we have passed half way through it and      // the scroll position is not off the image bottom.      if (isHalfWayThroughTheImage &amp;&amp; isNotOffTheImageBottom) {        image.classList.add(&#39;active&#39;);      } else {        image.classList.remove(&#39;active&#39;);      }    });  }  window.addEventListener(&#39;scroll&#39;, debounce(slideIn, 50));})(window);",
    "url": "https://miayam.github.io/javascript/2017/07/15/day13-javascript-challenge"
  }
</script>
<!-- End Jekyll SEO tag -->
</head>



  
    <body class="standard">
  

    <div class="container">
      <div class="grid">
        <aside class="cell -3of12" role="navigation">
          <div class="logo">
            <a href="/" class="logo_link">
              <img src="/images/personal_life.png" style="height: 165px" title="Back to the home page...">
            </a>
            <span class="bullshit">Delicious Meal for Thought</span>
          </div>
          <div class="t-hackcss-navigation">
  <h2 class="t-hackcss-navigation-heading">Main Menu</h2>

  <nav class="menu" role="menubar">
    
    
      <a class="menu-item "
        role="menuitem" href="/" title="">
        Home <div class="pull-right">»</div>
      </a>
    
      <a class="menu-item "
        role="menuitem" href="/about" title="">
        About <div class="pull-right">»</div>
      </a>
    
      <a class="menu-item "
        role="menuitem" href="/archive" title="">
        Archive <div class="pull-right">»</div>
      </a>
    
  </nav>
</div>

        </aside>

        <main class="cell -9of12">
          <article class="post" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title" itemprop="name headline">Day 13: JavaScript Challenge</h1>
    <p class="post-meta">
      <time datetime="2017-07-15T00:00:00+07:00"
            itemprop="datePublished"
            class="media-heading">
        15 July 2017
      </time>

      <span itemprop="author" itemscope itemtype="http://schema.org/Person">
        <span itemprop="name">written by <a href="https://github.com/miayam">Muhammad D. Ramadhan</a></span>
      </span>
    </p>
  </header>

  <div class="post-content" itemprop="articleBody">
    <p>It’s all about <code class="highlighter-rouge">debounce</code> function and the ‘scroll’ event I care about.</p>

<p><img src="/images/aoi_oh_aoi.jpg" alt="My dear!" class="blog-post-image" /></p>

<p>As I understand it, <code class="highlighter-rouge">debounce</code> function will prevent event listener
to fire every time the event it listen to occurred. Scrolling and resizing
are the best candidates because the function that listen to those activities
runs almost repeatedly and will significantly impact the browser’s performance.
<code class="highlighter-rouge">debounce</code> function will set the duration for event listener to delay until
certain amount of time have elapsed since the last time <code class="highlighter-rouge">debounce</code> function
was invoked. <code class="highlighter-rouge">debounce</code> makes use of <code class="highlighter-rouge">window.setTimeout</code>, for a good reason.
<a href="https://lodash.com/docs/4.17.4#debounce" target="_blank">Lodash</a> and
<a href="http://underscorejs.org/#debounce" target="_blank">Underscore.js</a>
have one of this kind.</p>

<p>Well, I cherry-pick the wording from blogs and documentations and cannot make
sure its originality. I am tired by the way.</p>

<p>Here’s the <a href="/demo_day13" target="_blank">demo</a> and a bit of explanation below…</p>

<noscript><pre>(function (window, undefined) {
  // These are images we want to slide in as we scroll half way through
  // them.
  var images = document.getElementsByClassName(&#39;slide-in&#39;);

  // It&#39;s for mapping DOM elements. The Array.prototype.forEach won&#39;t work
  // with NodeList.
  function forEach(callback) {
    for (var i = 0; i &lt; this.length; i++) {
      callback.call(this, this[i], i);
    }
  }

  // It&#39;s copy-pasted from internet, but I can explain this
  // interesting function in my own words.
  // It&#39;s well-explained by John Dugan http://bit.ly/2troSTT
  function debounce(func, wait = 20, immediate = true) {
    // It will store unique ID (number) that `window.setTimeout` return.
    // For more about &#39;window.setTimeout&#39;, visit https://mzl.la/2uuQs7Z
    var timeout;

    return function() {
      // In this case, `this` has reference to `window` object and
      // `arguments` is an array-like object that includes event
      // the `window` object listen to (&#39;scroll&#39;).
      var context = this, args = arguments;

      // This condition make function being passed to `debounce`
      // function (`func`) run without having to wait as long as
      // `timeout` is cleared away. So, the first time `debounce`
      // return this anonymous function and have it listen to &#39;scroll&#39;
      // event, `func` will run immediately.
      var callNow = immediate &amp;&amp; !timeout;

      // This function will fire after we have waited for certain amount
      // of time. `wait` parameter contains that duration.
      function later() {
        // Nullify the variable that stores unique ID (number) after the
        // timeout passed.
        timeout = null;

        // If we set `func` not to run immediately after `debounce` being
        // called, run it anyway after the timeout passed.
        if (!immediate) {
          func.apply(context, args);
        }
      };

      // Cancel the previous timeout, if there&#39;s any.
      clearTimeout(timeout);

      // Wait for a given time and run `later` function after it expires.
      // Store the unique ID (number) it returns.
      timeout = setTimeout(later, wait);

      if (callNow) {
        func.apply(context, args);
      }
    };
  }

  function slideIn(event) {
    // Window position relative to our view point. I mean, as we
    // scroll, at which position the window is?
    var windowPosition = window.scrollY + window.innerHeight;

    forEach.call(images, function (image) {
      var slideInAt = windowPosition - (image.height / 2.0);
      var imageBottom = image.offsetTop + image.height;
      var isHalfWayThroughTheImage = slideInAt &gt; image.offsetTop;
      var isNotOffTheImageBottom = window.scrollY &lt; imageBottom;

      // Slide in the image if we have passed half way through it and
      // the scroll position is not off the image bottom.
      if (isHalfWayThroughTheImage &amp;&amp; isNotOffTheImageBottom) {
        image.classList.add(&#39;active&#39;);
      } else {
        image.classList.remove(&#39;active&#39;);
      }
    });
  }

  window.addEventListener(&#39;scroll&#39;, debounce(slideIn, 50));
})(window);
</pre></noscript>
<script src="https://gist.github.com/miayam/fd94bb4549231a00dd9eee7e41f4eabc.js"> </script>


  </div>

  <div class="blog-navigation">
    <hr>
    
      <a href="/personal-life/2017/07/06/agama-dan-struktur-sosial" class="blog-navigation__previous-link">&laquo; Lima Perkara</a>
    
    
      <a href="/javascript/2017/07/16/day14-javascript-challenge" class="blog-navigation__next-link"> Day 14: JavaScript Challenge &raquo;</a>
    
  </div>
</article>

<section>
  <div class="fb-comments" data-href="https://miayam.github.io/javascript/2017/07/15/day13-javascript-challenge" data-width="100%" data-numposts="10">
  </div>
</section>

        </main>
      </div>

    <footer class="t-hackcss-footer">
  <div class="cell -12of12">
    <div class="contact-list">
    </div>
  </div>
</footer>


    </div>

    <!-- Prism.js -->
    <script src="https://npmcdn.com/prismjs@1.5.1/prism.js"></script>
  </body>
  <div id="fb-root"></div>
  <script>
    (function(d, s, id) {
      var js, fjs = d.getElementsByTagName(s)[0];
      if (d.getElementById(id)) {
        d.getElementById('loading').style.display = "none";
        return;
      }
      js = d.createElement(s); js.id = id;
      js.src = "//connect.facebook.net/en_GB/sdk.js#xfbml=1&version=v2.9&appId=676883012507478";
      fjs.parentNode.insertBefore(js, fjs);
    }(document, 'script', 'facebook-jssdk'));
  </script>

  <script src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js?config=TeX-AMS-MML_HTMLorMML" type="text/javascript"></script>
</html>
